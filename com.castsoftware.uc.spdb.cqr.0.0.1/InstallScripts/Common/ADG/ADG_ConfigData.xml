<?xml version='1.0' encoding='utf-8'?>
<DATA model='Central Model' version='1.1' scope='FULL_CONTENT' export='OK'><!-- File generated with CAST Metrics Compiler ##VERSION_BUILD## -->
  <DSS_METRIC_TYPES>
    <METRIC_ID>2004002</METRIC_ID>
    <METRIC_NAME>Initialize the variable while defining it</METRIC_NAME>
    <METRIC_DESCRIPTION>See Metric Documentation</METRIC_DESCRIPTION>
    <METRIC_TYPE>3</METRIC_TYPE>
    <METRIC_GROUP>1</METRIC_GROUP>
    <METRIC_DEPENDS_ON>$n$u$l$l$</METRIC_DEPENDS_ON>
    <METRIC_OPTIONS>0</METRIC_OPTIONS>
    <SCOPE_ID>2004000</SCOPE_ID>
    <PROPERTY_ID>2004002</PROPERTY_ID>
  </DSS_METRIC_TYPES>
  <DSS_METRIC_TYPES>
    <METRIC_ID>2004003</METRIC_ID>
    <METRIC_NAME>Initialize the variable while defining it</METRIC_NAME>
    <METRIC_DESCRIPTION>description details</METRIC_DESCRIPTION>
    <METRIC_TYPE>2</METRIC_TYPE>
    <METRIC_GROUP>2</METRIC_GROUP>
    <METRIC_DEPENDS_ON>$n$u$l$l$</METRIC_DEPENDS_ON>
    <METRIC_OPTIONS>0</METRIC_OPTIONS>
    <SCOPE_ID>0</SCOPE_ID>
    <PROPERTY_ID>0</PROPERTY_ID>
  </DSS_METRIC_TYPES>
  <DSS_METRIC_TYPES>
    <METRIC_ID>2004004</METRIC_ID>
    <METRIC_NAME>Avoid return Pointer, because memory exists and is destroyed automatically at the end of the function body</METRIC_NAME>
    <METRIC_DESCRIPTION>See Metric Documentation</METRIC_DESCRIPTION>
    <METRIC_TYPE>3</METRIC_TYPE>
    <METRIC_GROUP>1</METRIC_GROUP>
    <METRIC_DEPENDS_ON>$n$u$l$l$</METRIC_DEPENDS_ON>
    <METRIC_OPTIONS>0</METRIC_OPTIONS>
    <SCOPE_ID>2004000</SCOPE_ID>
    <PROPERTY_ID>2004004</PROPERTY_ID>
  </DSS_METRIC_TYPES>
  <DSS_METRIC_TYPES>
    <METRIC_ID>2004005</METRIC_ID>
    <METRIC_NAME>Avoid return Pointer, because memory exists and is destroyed automatically at the end of the function body</METRIC_NAME>
    <METRIC_DESCRIPTION>description details</METRIC_DESCRIPTION>
    <METRIC_TYPE>2</METRIC_TYPE>
    <METRIC_GROUP>2</METRIC_GROUP>
    <METRIC_DEPENDS_ON>$n$u$l$l$</METRIC_DEPENDS_ON>
    <METRIC_OPTIONS>0</METRIC_OPTIONS>
    <SCOPE_ID>0</SCOPE_ID>
    <PROPERTY_ID>0</PROPERTY_ID>
  </DSS_METRIC_TYPES>
  <DSS_METRIC_TYPES>
    <METRIC_ID>2004006</METRIC_ID>
    <METRIC_NAME>Once memory is applied with malloc, it should be immediately checked whether the pointer value is NULL</METRIC_NAME>
    <METRIC_DESCRIPTION>See Metric Documentation</METRIC_DESCRIPTION>
    <METRIC_TYPE>3</METRIC_TYPE>
    <METRIC_GROUP>1</METRIC_GROUP>
    <METRIC_DEPENDS_ON>$n$u$l$l$</METRIC_DEPENDS_ON>
    <METRIC_OPTIONS>0</METRIC_OPTIONS>
    <SCOPE_ID>2004000</SCOPE_ID>
    <PROPERTY_ID>2004006</PROPERTY_ID>
  </DSS_METRIC_TYPES>
  <DSS_METRIC_TYPES>
    <METRIC_ID>2004007</METRIC_ID>
    <METRIC_NAME>Once memory is applied with malloc, it should be immediately checked whether the pointer value is NULL</METRIC_NAME>
    <METRIC_DESCRIPTION>description details</METRIC_DESCRIPTION>
    <METRIC_TYPE>2</METRIC_TYPE>
    <METRIC_GROUP>2</METRIC_GROUP>
    <METRIC_DEPENDS_ON>$n$u$l$l$</METRIC_DEPENDS_ON>
    <METRIC_OPTIONS>0</METRIC_OPTIONS>
    <SCOPE_ID>0</SCOPE_ID>
    <PROPERTY_ID>0</PROPERTY_ID>
  </DSS_METRIC_TYPES>
  <DSS_METRIC_TYPES>
    <METRIC_ID>2004008</METRIC_ID>
    <METRIC_NAME>Set the pointer to NULL immediately after freeing memory with free to prevent 'Wild Pointers'</METRIC_NAME>
    <METRIC_DESCRIPTION>See Metric Documentation</METRIC_DESCRIPTION>
    <METRIC_TYPE>3</METRIC_TYPE>
    <METRIC_GROUP>1</METRIC_GROUP>
    <METRIC_DEPENDS_ON>$n$u$l$l$</METRIC_DEPENDS_ON>
    <METRIC_OPTIONS>0</METRIC_OPTIONS>
    <SCOPE_ID>2004000</SCOPE_ID>
    <PROPERTY_ID>2004008</PROPERTY_ID>
  </DSS_METRIC_TYPES>
  <DSS_METRIC_TYPES>
    <METRIC_ID>2004009</METRIC_ID>
    <METRIC_NAME>Set the pointer to NULL immediately after freeing memory with free to prevent 'Wild Pointers'</METRIC_NAME>
    <METRIC_DESCRIPTION>description details</METRIC_DESCRIPTION>
    <METRIC_TYPE>2</METRIC_TYPE>
    <METRIC_GROUP>2</METRIC_GROUP>
    <METRIC_DEPENDS_ON>$n$u$l$l$</METRIC_DEPENDS_ON>
    <METRIC_OPTIONS>0</METRIC_OPTIONS>
    <SCOPE_ID>0</SCOPE_ID>
    <PROPERTY_ID>0</PROPERTY_ID>
  </DSS_METRIC_TYPES>
  <DSS_METRIC_TYPE_TREES>
    <METRIC_PARENT_ID>61024</METRIC_PARENT_ID>
    <METRIC_ID>2004002</METRIC_ID>
    <METRIC_INDEX>2</METRIC_INDEX>
    <AGGREGATE_WEIGHT>6</AGGREGATE_WEIGHT>
    <METRIC_SCOPE_PROCEDURE_NAME>DSS_FILTER_SCOPE</METRIC_SCOPE_PROCEDURE_NAME>
    <METRIC_SCOPE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_SCOPE_PROCEDURE_NAME_2>
    <METRIC_CRITICAL>1</METRIC_CRITICAL>
  </DSS_METRIC_TYPE_TREES>
  <DSS_METRIC_TYPE_TREES>
    <METRIC_PARENT_ID>61024</METRIC_PARENT_ID>
    <METRIC_ID>2004004</METRIC_ID>
    <METRIC_INDEX>3</METRIC_INDEX>
    <AGGREGATE_WEIGHT>6</AGGREGATE_WEIGHT>
    <METRIC_SCOPE_PROCEDURE_NAME>DSS_FILTER_SCOPE</METRIC_SCOPE_PROCEDURE_NAME>
    <METRIC_SCOPE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_SCOPE_PROCEDURE_NAME_2>
    <METRIC_CRITICAL>1</METRIC_CRITICAL>
  </DSS_METRIC_TYPE_TREES>
  <DSS_METRIC_TYPE_TREES>
    <METRIC_PARENT_ID>61024</METRIC_PARENT_ID>
    <METRIC_ID>2004006</METRIC_ID>
    <METRIC_INDEX>4</METRIC_INDEX>
    <AGGREGATE_WEIGHT>6</AGGREGATE_WEIGHT>
    <METRIC_SCOPE_PROCEDURE_NAME>DSS_FILTER_SCOPE</METRIC_SCOPE_PROCEDURE_NAME>
    <METRIC_SCOPE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_SCOPE_PROCEDURE_NAME_2>
    <METRIC_CRITICAL>1</METRIC_CRITICAL>
  </DSS_METRIC_TYPE_TREES>
  <DSS_METRIC_TYPE_TREES>
    <METRIC_PARENT_ID>61024</METRIC_PARENT_ID>
    <METRIC_ID>2004008</METRIC_ID>
    <METRIC_INDEX>5</METRIC_INDEX>
    <AGGREGATE_WEIGHT>6</AGGREGATE_WEIGHT>
    <METRIC_SCOPE_PROCEDURE_NAME>DSS_FILTER_SCOPE</METRIC_SCOPE_PROCEDURE_NAME>
    <METRIC_SCOPE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_SCOPE_PROCEDURE_NAME_2>
    <METRIC_CRITICAL>1</METRIC_CRITICAL>
  </DSS_METRIC_TYPE_TREES>
  <DSS_METRIC_TYPE_TREES>
    <METRIC_PARENT_ID>2004002</METRIC_PARENT_ID>
    <METRIC_ID>2004003</METRIC_ID>
    <METRIC_INDEX>1</METRIC_INDEX>
    <AGGREGATE_WEIGHT>1</AGGREGATE_WEIGHT>
    <METRIC_SCOPE_PROCEDURE_NAME>DSS_DIAG_SCOPE_GENERIC_NUM</METRIC_SCOPE_PROCEDURE_NAME>
    <METRIC_SCOPE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_SCOPE_PROCEDURE_NAME_2>
    <METRIC_CRITICAL>0</METRIC_CRITICAL>
  </DSS_METRIC_TYPE_TREES>
  <DSS_METRIC_TYPE_TREES>
    <METRIC_PARENT_ID>2004004</METRIC_PARENT_ID>
    <METRIC_ID>2004005</METRIC_ID>
    <METRIC_INDEX>1</METRIC_INDEX>
    <AGGREGATE_WEIGHT>1</AGGREGATE_WEIGHT>
    <METRIC_SCOPE_PROCEDURE_NAME>DSS_DIAG_SCOPE_GENERIC_NUM</METRIC_SCOPE_PROCEDURE_NAME>
    <METRIC_SCOPE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_SCOPE_PROCEDURE_NAME_2>
    <METRIC_CRITICAL>0</METRIC_CRITICAL>
  </DSS_METRIC_TYPE_TREES>
  <DSS_METRIC_TYPE_TREES>
    <METRIC_PARENT_ID>2004006</METRIC_PARENT_ID>
    <METRIC_ID>2004007</METRIC_ID>
    <METRIC_INDEX>1</METRIC_INDEX>
    <AGGREGATE_WEIGHT>1</AGGREGATE_WEIGHT>
    <METRIC_SCOPE_PROCEDURE_NAME>DSS_DIAG_SCOPE_GENERIC_NUM</METRIC_SCOPE_PROCEDURE_NAME>
    <METRIC_SCOPE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_SCOPE_PROCEDURE_NAME_2>
    <METRIC_CRITICAL>0</METRIC_CRITICAL>
  </DSS_METRIC_TYPE_TREES>
  <DSS_METRIC_TYPE_TREES>
    <METRIC_PARENT_ID>2004008</METRIC_PARENT_ID>
    <METRIC_ID>2004009</METRIC_ID>
    <METRIC_INDEX>1</METRIC_INDEX>
    <AGGREGATE_WEIGHT>1</AGGREGATE_WEIGHT>
    <METRIC_SCOPE_PROCEDURE_NAME>DSS_DIAG_SCOPE_GENERIC_NUM</METRIC_SCOPE_PROCEDURE_NAME>
    <METRIC_SCOPE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_SCOPE_PROCEDURE_NAME_2>
    <METRIC_CRITICAL>0</METRIC_CRITICAL>
  </DSS_METRIC_TYPE_TREES>
  <DSS_METRIC_VALUE_TYPES>
    <METRIC_ID>2004002</METRIC_ID>
    <METRIC_VALUE_INDEX>0</METRIC_VALUE_INDEX>
    <METRIC_VALUE_NAME>Grade and status distribution</METRIC_VALUE_NAME>
    <METRIC_VALUE_DESCRIPTION>Generic grade and status distribution calculation for diagnostics</METRIC_VALUE_DESCRIPTION>
    <METRIC_VALUE_PROCEDURE_NAME>ADG_RESULT_DIAG_STATUS</METRIC_VALUE_PROCEDURE_NAME>
    <METRIC_AGGREGATE_OPERATOR>0</METRIC_AGGREGATE_OPERATOR>
    <METRIC_VALUE_PROCEDURE_NAME_2>ADG_CENTRAL_RESULT_DIAG</METRIC_VALUE_PROCEDURE_NAME_2>
    <METRIC_AGGREGATE_OPERATOR_2>0</METRIC_AGGREGATE_OPERATOR_2>
    <METRIC_VALUE_TYPE>0</METRIC_VALUE_TYPE>
  </DSS_METRIC_VALUE_TYPES>
  <DSS_METRIC_VALUE_TYPES>
    <METRIC_ID>2004002</METRIC_ID>
    <METRIC_VALUE_INDEX>1</METRIC_VALUE_INDEX>
    <METRIC_VALUE_NAME>Initialize the variable while defining it</METRIC_VALUE_NAME>
    <METRIC_VALUE_DESCRIPTION>See Metric documentation</METRIC_VALUE_DESCRIPTION>
    <METRIC_VALUE_PROCEDURE_NAME>$n$u$l$l$</METRIC_VALUE_PROCEDURE_NAME>
    <METRIC_AGGREGATE_OPERATOR>11</METRIC_AGGREGATE_OPERATOR>
    <METRIC_VALUE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_VALUE_PROCEDURE_NAME_2>
    <METRIC_AGGREGATE_OPERATOR_2>0</METRIC_AGGREGATE_OPERATOR_2>
    <METRIC_VALUE_TYPE>5</METRIC_VALUE_TYPE>
  </DSS_METRIC_VALUE_TYPES>
  <DSS_METRIC_VALUE_TYPES>
    <METRIC_ID>2004002</METRIC_ID>
    <METRIC_VALUE_INDEX>2</METRIC_VALUE_INDEX>
    <METRIC_VALUE_NAME>total</METRIC_VALUE_NAME>
    <METRIC_VALUE_DESCRIPTION>total</METRIC_VALUE_DESCRIPTION>
    <METRIC_VALUE_PROCEDURE_NAME>DSS_DIAG_TOTAL_GENERIC</METRIC_VALUE_PROCEDURE_NAME>
    <METRIC_AGGREGATE_OPERATOR>0</METRIC_AGGREGATE_OPERATOR>
    <METRIC_VALUE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_VALUE_PROCEDURE_NAME_2>
    <METRIC_AGGREGATE_OPERATOR_2>0</METRIC_AGGREGATE_OPERATOR_2>
    <METRIC_VALUE_TYPE>5</METRIC_VALUE_TYPE>
  </DSS_METRIC_VALUE_TYPES>
  <DSS_METRIC_VALUE_TYPES>
    <METRIC_ID>2004003</METRIC_ID>
    <METRIC_VALUE_INDEX>1</METRIC_VALUE_INDEX>
    <METRIC_VALUE_NAME>detail</METRIC_VALUE_NAME>
    <METRIC_VALUE_DESCRIPTION>detail</METRIC_VALUE_DESCRIPTION>
    <METRIC_VALUE_PROCEDURE_NAME>DSS_METRIC_VALUE_SCOPE</METRIC_VALUE_PROCEDURE_NAME>
    <METRIC_AGGREGATE_OPERATOR>0</METRIC_AGGREGATE_OPERATOR>
    <METRIC_VALUE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_VALUE_PROCEDURE_NAME_2>
    <METRIC_AGGREGATE_OPERATOR_2>0</METRIC_AGGREGATE_OPERATOR_2>
    <METRIC_VALUE_TYPE>5</METRIC_VALUE_TYPE>
  </DSS_METRIC_VALUE_TYPES>
  <DSS_METRIC_VALUE_TYPES>
    <METRIC_ID>2004004</METRIC_ID>
    <METRIC_VALUE_INDEX>0</METRIC_VALUE_INDEX>
    <METRIC_VALUE_NAME>Grade and status distribution</METRIC_VALUE_NAME>
    <METRIC_VALUE_DESCRIPTION>Generic grade and status distribution calculation for diagnostics</METRIC_VALUE_DESCRIPTION>
    <METRIC_VALUE_PROCEDURE_NAME>ADG_RESULT_DIAG_STATUS</METRIC_VALUE_PROCEDURE_NAME>
    <METRIC_AGGREGATE_OPERATOR>0</METRIC_AGGREGATE_OPERATOR>
    <METRIC_VALUE_PROCEDURE_NAME_2>ADG_CENTRAL_RESULT_DIAG</METRIC_VALUE_PROCEDURE_NAME_2>
    <METRIC_AGGREGATE_OPERATOR_2>0</METRIC_AGGREGATE_OPERATOR_2>
    <METRIC_VALUE_TYPE>0</METRIC_VALUE_TYPE>
  </DSS_METRIC_VALUE_TYPES>
  <DSS_METRIC_VALUE_TYPES>
    <METRIC_ID>2004004</METRIC_ID>
    <METRIC_VALUE_INDEX>1</METRIC_VALUE_INDEX>
    <METRIC_VALUE_NAME>Avoid return Pointer, because memory exists and is destroyed automatically at the end of the function body</METRIC_VALUE_NAME>
    <METRIC_VALUE_DESCRIPTION>See Metric documentation</METRIC_VALUE_DESCRIPTION>
    <METRIC_VALUE_PROCEDURE_NAME>$n$u$l$l$</METRIC_VALUE_PROCEDURE_NAME>
    <METRIC_AGGREGATE_OPERATOR>11</METRIC_AGGREGATE_OPERATOR>
    <METRIC_VALUE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_VALUE_PROCEDURE_NAME_2>
    <METRIC_AGGREGATE_OPERATOR_2>0</METRIC_AGGREGATE_OPERATOR_2>
    <METRIC_VALUE_TYPE>5</METRIC_VALUE_TYPE>
  </DSS_METRIC_VALUE_TYPES>
  <DSS_METRIC_VALUE_TYPES>
    <METRIC_ID>2004004</METRIC_ID>
    <METRIC_VALUE_INDEX>2</METRIC_VALUE_INDEX>
    <METRIC_VALUE_NAME>total</METRIC_VALUE_NAME>
    <METRIC_VALUE_DESCRIPTION>total</METRIC_VALUE_DESCRIPTION>
    <METRIC_VALUE_PROCEDURE_NAME>DSS_DIAG_TOTAL_GENERIC</METRIC_VALUE_PROCEDURE_NAME>
    <METRIC_AGGREGATE_OPERATOR>0</METRIC_AGGREGATE_OPERATOR>
    <METRIC_VALUE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_VALUE_PROCEDURE_NAME_2>
    <METRIC_AGGREGATE_OPERATOR_2>0</METRIC_AGGREGATE_OPERATOR_2>
    <METRIC_VALUE_TYPE>5</METRIC_VALUE_TYPE>
  </DSS_METRIC_VALUE_TYPES>
  <DSS_METRIC_VALUE_TYPES>
    <METRIC_ID>2004005</METRIC_ID>
    <METRIC_VALUE_INDEX>1</METRIC_VALUE_INDEX>
    <METRIC_VALUE_NAME>detail</METRIC_VALUE_NAME>
    <METRIC_VALUE_DESCRIPTION>detail</METRIC_VALUE_DESCRIPTION>
    <METRIC_VALUE_PROCEDURE_NAME>DSS_METRIC_VALUE_SCOPE</METRIC_VALUE_PROCEDURE_NAME>
    <METRIC_AGGREGATE_OPERATOR>0</METRIC_AGGREGATE_OPERATOR>
    <METRIC_VALUE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_VALUE_PROCEDURE_NAME_2>
    <METRIC_AGGREGATE_OPERATOR_2>0</METRIC_AGGREGATE_OPERATOR_2>
    <METRIC_VALUE_TYPE>5</METRIC_VALUE_TYPE>
  </DSS_METRIC_VALUE_TYPES>
  <DSS_METRIC_VALUE_TYPES>
    <METRIC_ID>2004006</METRIC_ID>
    <METRIC_VALUE_INDEX>0</METRIC_VALUE_INDEX>
    <METRIC_VALUE_NAME>Grade and status distribution</METRIC_VALUE_NAME>
    <METRIC_VALUE_DESCRIPTION>Generic grade and status distribution calculation for diagnostics</METRIC_VALUE_DESCRIPTION>
    <METRIC_VALUE_PROCEDURE_NAME>ADG_RESULT_DIAG_STATUS</METRIC_VALUE_PROCEDURE_NAME>
    <METRIC_AGGREGATE_OPERATOR>0</METRIC_AGGREGATE_OPERATOR>
    <METRIC_VALUE_PROCEDURE_NAME_2>ADG_CENTRAL_RESULT_DIAG</METRIC_VALUE_PROCEDURE_NAME_2>
    <METRIC_AGGREGATE_OPERATOR_2>0</METRIC_AGGREGATE_OPERATOR_2>
    <METRIC_VALUE_TYPE>0</METRIC_VALUE_TYPE>
  </DSS_METRIC_VALUE_TYPES>
  <DSS_METRIC_VALUE_TYPES>
    <METRIC_ID>2004006</METRIC_ID>
    <METRIC_VALUE_INDEX>1</METRIC_VALUE_INDEX>
    <METRIC_VALUE_NAME>Once memory is applied with malloc, it should be immediately checked whether the pointer value is NULL</METRIC_VALUE_NAME>
    <METRIC_VALUE_DESCRIPTION>See Metric documentation</METRIC_VALUE_DESCRIPTION>
    <METRIC_VALUE_PROCEDURE_NAME>$n$u$l$l$</METRIC_VALUE_PROCEDURE_NAME>
    <METRIC_AGGREGATE_OPERATOR>11</METRIC_AGGREGATE_OPERATOR>
    <METRIC_VALUE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_VALUE_PROCEDURE_NAME_2>
    <METRIC_AGGREGATE_OPERATOR_2>0</METRIC_AGGREGATE_OPERATOR_2>
    <METRIC_VALUE_TYPE>5</METRIC_VALUE_TYPE>
  </DSS_METRIC_VALUE_TYPES>
  <DSS_METRIC_VALUE_TYPES>
    <METRIC_ID>2004006</METRIC_ID>
    <METRIC_VALUE_INDEX>2</METRIC_VALUE_INDEX>
    <METRIC_VALUE_NAME>total</METRIC_VALUE_NAME>
    <METRIC_VALUE_DESCRIPTION>total</METRIC_VALUE_DESCRIPTION>
    <METRIC_VALUE_PROCEDURE_NAME>DSS_DIAG_TOTAL_GENERIC</METRIC_VALUE_PROCEDURE_NAME>
    <METRIC_AGGREGATE_OPERATOR>0</METRIC_AGGREGATE_OPERATOR>
    <METRIC_VALUE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_VALUE_PROCEDURE_NAME_2>
    <METRIC_AGGREGATE_OPERATOR_2>0</METRIC_AGGREGATE_OPERATOR_2>
    <METRIC_VALUE_TYPE>5</METRIC_VALUE_TYPE>
  </DSS_METRIC_VALUE_TYPES>
  <DSS_METRIC_VALUE_TYPES>
    <METRIC_ID>2004007</METRIC_ID>
    <METRIC_VALUE_INDEX>1</METRIC_VALUE_INDEX>
    <METRIC_VALUE_NAME>detail</METRIC_VALUE_NAME>
    <METRIC_VALUE_DESCRIPTION>detail</METRIC_VALUE_DESCRIPTION>
    <METRIC_VALUE_PROCEDURE_NAME>DSS_METRIC_VALUE_SCOPE</METRIC_VALUE_PROCEDURE_NAME>
    <METRIC_AGGREGATE_OPERATOR>0</METRIC_AGGREGATE_OPERATOR>
    <METRIC_VALUE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_VALUE_PROCEDURE_NAME_2>
    <METRIC_AGGREGATE_OPERATOR_2>0</METRIC_AGGREGATE_OPERATOR_2>
    <METRIC_VALUE_TYPE>5</METRIC_VALUE_TYPE>
  </DSS_METRIC_VALUE_TYPES>
  <DSS_METRIC_VALUE_TYPES>
    <METRIC_ID>2004008</METRIC_ID>
    <METRIC_VALUE_INDEX>0</METRIC_VALUE_INDEX>
    <METRIC_VALUE_NAME>Grade and status distribution</METRIC_VALUE_NAME>
    <METRIC_VALUE_DESCRIPTION>Generic grade and status distribution calculation for diagnostics</METRIC_VALUE_DESCRIPTION>
    <METRIC_VALUE_PROCEDURE_NAME>ADG_RESULT_DIAG_STATUS</METRIC_VALUE_PROCEDURE_NAME>
    <METRIC_AGGREGATE_OPERATOR>0</METRIC_AGGREGATE_OPERATOR>
    <METRIC_VALUE_PROCEDURE_NAME_2>ADG_CENTRAL_RESULT_DIAG</METRIC_VALUE_PROCEDURE_NAME_2>
    <METRIC_AGGREGATE_OPERATOR_2>0</METRIC_AGGREGATE_OPERATOR_2>
    <METRIC_VALUE_TYPE>0</METRIC_VALUE_TYPE>
  </DSS_METRIC_VALUE_TYPES>
  <DSS_METRIC_VALUE_TYPES>
    <METRIC_ID>2004008</METRIC_ID>
    <METRIC_VALUE_INDEX>1</METRIC_VALUE_INDEX>
    <METRIC_VALUE_NAME>Set the pointer to NULL immediately after freeing memory with free to prevent 'Wild Pointers'</METRIC_VALUE_NAME>
    <METRIC_VALUE_DESCRIPTION>See Metric documentation</METRIC_VALUE_DESCRIPTION>
    <METRIC_VALUE_PROCEDURE_NAME>$n$u$l$l$</METRIC_VALUE_PROCEDURE_NAME>
    <METRIC_AGGREGATE_OPERATOR>11</METRIC_AGGREGATE_OPERATOR>
    <METRIC_VALUE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_VALUE_PROCEDURE_NAME_2>
    <METRIC_AGGREGATE_OPERATOR_2>0</METRIC_AGGREGATE_OPERATOR_2>
    <METRIC_VALUE_TYPE>5</METRIC_VALUE_TYPE>
  </DSS_METRIC_VALUE_TYPES>
  <DSS_METRIC_VALUE_TYPES>
    <METRIC_ID>2004008</METRIC_ID>
    <METRIC_VALUE_INDEX>2</METRIC_VALUE_INDEX>
    <METRIC_VALUE_NAME>total</METRIC_VALUE_NAME>
    <METRIC_VALUE_DESCRIPTION>total</METRIC_VALUE_DESCRIPTION>
    <METRIC_VALUE_PROCEDURE_NAME>DSS_DIAG_TOTAL_GENERIC</METRIC_VALUE_PROCEDURE_NAME>
    <METRIC_AGGREGATE_OPERATOR>0</METRIC_AGGREGATE_OPERATOR>
    <METRIC_VALUE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_VALUE_PROCEDURE_NAME_2>
    <METRIC_AGGREGATE_OPERATOR_2>0</METRIC_AGGREGATE_OPERATOR_2>
    <METRIC_VALUE_TYPE>5</METRIC_VALUE_TYPE>
  </DSS_METRIC_VALUE_TYPES>
  <DSS_METRIC_VALUE_TYPES>
    <METRIC_ID>2004009</METRIC_ID>
    <METRIC_VALUE_INDEX>1</METRIC_VALUE_INDEX>
    <METRIC_VALUE_NAME>detail</METRIC_VALUE_NAME>
    <METRIC_VALUE_DESCRIPTION>detail</METRIC_VALUE_DESCRIPTION>
    <METRIC_VALUE_PROCEDURE_NAME>DSS_METRIC_VALUE_SCOPE</METRIC_VALUE_PROCEDURE_NAME>
    <METRIC_AGGREGATE_OPERATOR>0</METRIC_AGGREGATE_OPERATOR>
    <METRIC_VALUE_PROCEDURE_NAME_2>$n$u$l$l$</METRIC_VALUE_PROCEDURE_NAME_2>
    <METRIC_AGGREGATE_OPERATOR_2>0</METRIC_AGGREGATE_OPERATOR_2>
    <METRIC_VALUE_TYPE>5</METRIC_VALUE_TYPE>
  </DSS_METRIC_VALUE_TYPES>
  <DSS_METRIC_PARAM_TYPES>
    <METRIC_ID>2004003</METRIC_ID>
    <PARAM_INDEX>1</PARAM_INDEX>
    <OBJECT_TYPE_ID>0</OBJECT_TYPE_ID>
    <PARAM_TYPE>2</PARAM_TYPE>
    <PARAM_NAME>Maximum Line Count</PARAM_NAME>
    <PARAM_DESCRIPTION>Maximum Count per artifact</PARAM_DESCRIPTION>
  </DSS_METRIC_PARAM_TYPES>
  <DSS_METRIC_PARAM_TYPES>
    <METRIC_ID>2004005</METRIC_ID>
    <PARAM_INDEX>1</PARAM_INDEX>
    <OBJECT_TYPE_ID>0</OBJECT_TYPE_ID>
    <PARAM_TYPE>2</PARAM_TYPE>
    <PARAM_NAME>Maximum Line Count</PARAM_NAME>
    <PARAM_DESCRIPTION>Maximum gdpr Count per artifact</PARAM_DESCRIPTION>
  </DSS_METRIC_PARAM_TYPES>
  <DSS_METRIC_PARAM_TYPES>
    <METRIC_ID>2004007</METRIC_ID>
    <PARAM_INDEX>1</PARAM_INDEX>
    <OBJECT_TYPE_ID>0</OBJECT_TYPE_ID>
    <PARAM_TYPE>2</PARAM_TYPE>
    <PARAM_NAME>Maximum Line Count</PARAM_NAME>
    <PARAM_DESCRIPTION>Maximum gdpr Count per artifact</PARAM_DESCRIPTION>
  </DSS_METRIC_PARAM_TYPES>
  <DSS_METRIC_PARAM_TYPES>
    <METRIC_ID>2004009</METRIC_ID>
    <PARAM_INDEX>1</PARAM_INDEX>
    <OBJECT_TYPE_ID>0</OBJECT_TYPE_ID>
    <PARAM_TYPE>2</PARAM_TYPE>
    <PARAM_NAME>Maximum Line Count</PARAM_NAME>
    <PARAM_DESCRIPTION>Maximum gdpr Count per artifact</PARAM_DESCRIPTION>
  </DSS_METRIC_PARAM_TYPES>
  <DSS_METRIC_PARAM_VALUES>
    <METRIC_ID>2004003</METRIC_ID>
    <PARAM_INDEX>1</PARAM_INDEX>
    <OBJECT_TYPE_ID>0</OBJECT_TYPE_ID>
    <PARAM_NUM_VALUE>100</PARAM_NUM_VALUE>
    <PARAM_CHAR_VALUE>$n$u$l$l$</PARAM_CHAR_VALUE>
    <PARAM_ORDER>0</PARAM_ORDER>
  </DSS_METRIC_PARAM_VALUES>
  <DSS_METRIC_PARAM_VALUES>
    <METRIC_ID>2004005</METRIC_ID>
    <PARAM_INDEX>1</PARAM_INDEX>
    <OBJECT_TYPE_ID>0</OBJECT_TYPE_ID>
    <PARAM_NUM_VALUE>100</PARAM_NUM_VALUE>
    <PARAM_CHAR_VALUE>$n$u$l$l$</PARAM_CHAR_VALUE>
    <PARAM_ORDER>0</PARAM_ORDER>
  </DSS_METRIC_PARAM_VALUES>
  <DSS_METRIC_PARAM_VALUES>
    <METRIC_ID>2004007</METRIC_ID>
    <PARAM_INDEX>1</PARAM_INDEX>
    <OBJECT_TYPE_ID>0</OBJECT_TYPE_ID>
    <PARAM_NUM_VALUE>100</PARAM_NUM_VALUE>
    <PARAM_CHAR_VALUE>$n$u$l$l$</PARAM_CHAR_VALUE>
    <PARAM_ORDER>0</PARAM_ORDER>
  </DSS_METRIC_PARAM_VALUES>
  <DSS_METRIC_PARAM_VALUES>
    <METRIC_ID>2004009</METRIC_ID>
    <PARAM_INDEX>1</PARAM_INDEX>
    <OBJECT_TYPE_ID>0</OBJECT_TYPE_ID>
    <PARAM_NUM_VALUE>100</PARAM_NUM_VALUE>
    <PARAM_CHAR_VALUE>$n$u$l$l$</PARAM_CHAR_VALUE>
    <PARAM_ORDER>0</PARAM_ORDER>
  </DSS_METRIC_PARAM_VALUES>
  <DSS_METRIC_STATUS_THRESHOLDS>
    <METRIC_ID>2004002</METRIC_ID>
    <STATUS>0</STATUS>
    <THRESHOLD_1>50.0</THRESHOLD_1>
    <THRESHOLD_2>90.0</THRESHOLD_2>
    <THRESHOLD_3>95.0</THRESHOLD_3>
    <THRESHOLD_4>99.0</THRESHOLD_4>
  </DSS_METRIC_STATUS_THRESHOLDS>
  <DSS_METRIC_STATUS_THRESHOLDS>
    <METRIC_ID>2004004</METRIC_ID>
    <STATUS>0</STATUS>
    <THRESHOLD_1>50.0</THRESHOLD_1>
    <THRESHOLD_2>90.0</THRESHOLD_2>
    <THRESHOLD_3>95.0</THRESHOLD_3>
    <THRESHOLD_4>99.0</THRESHOLD_4>
  </DSS_METRIC_STATUS_THRESHOLDS>
  <DSS_METRIC_STATUS_THRESHOLDS>
    <METRIC_ID>2004006</METRIC_ID>
    <STATUS>0</STATUS>
    <THRESHOLD_1>50.0</THRESHOLD_1>
    <THRESHOLD_2>90.0</THRESHOLD_2>
    <THRESHOLD_3>95.0</THRESHOLD_3>
    <THRESHOLD_4>99.0</THRESHOLD_4>
  </DSS_METRIC_STATUS_THRESHOLDS>
  <DSS_METRIC_STATUS_THRESHOLDS>
    <METRIC_ID>2004008</METRIC_ID>
    <STATUS>0</STATUS>
    <THRESHOLD_1>50.0</THRESHOLD_1>
    <THRESHOLD_2>90.0</THRESHOLD_2>
    <THRESHOLD_3>95.0</THRESHOLD_3>
    <THRESHOLD_4>99.0</THRESHOLD_4>
  </DSS_METRIC_STATUS_THRESHOLDS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004002</METRIC_ID>
    <DESCRIPTION_TYPE_ID>0</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Initialize the variable while defining it</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004002</METRIC_ID>
    <DESCRIPTION_TYPE_ID>1</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Variables are defined but it is not initialized with temporary / default values</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004002</METRIC_ID>
    <DESCRIPTION_TYPE_ID>2</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Un-itialized variables may contain junk data with the contents of stack memory before the function was invoked. So An attacker can sometimes control or read these contents. In other languages or conditions, a variable that is not explicitly initialized can be given a default value that has security implications, depending on the logic of the program. The presence of an uninitialized variable can sometimes indicate a typographic error in the code.</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004002</METRIC_ID>
    <DESCRIPTION_TYPE_ID>3</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>All the variables must be initialized while defining it</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004002</METRIC_ID>
    <DESCRIPTION_TYPE_ID>5</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Sample: int x = 500</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004002</METRIC_ID>
    <DESCRIPTION_TYPE_ID>6</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Initialize the variable while defining it.
	    For example define the variable and initialize like below:
	    	===&gt; int a = 100
	    </METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004002</METRIC_ID>
    <DESCRIPTION_TYPE_ID>7</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Security, Architectural, improper behavior of the program can be avoided</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004002</METRIC_ID>
    <DESCRIPTION_TYPE_ID>8</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>The total procedure counts Components Access.</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004002</METRIC_ID>
    <DESCRIPTION_TYPE_ID>9</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Asoociated Values: Initialize the variable while defining it</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004004</METRIC_ID>
    <DESCRIPTION_TYPE_ID>0</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Avoid return Pointer, because memory exists and is destroyed automatically at the end of the function body</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004004</METRIC_ID>
    <DESCRIPTION_TYPE_ID>1</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>This check detects anytime the memory for a stack variable declared in a function is accessed after that function returns. Attempting to access stack memory after a function return can result in a crash or other unpredictable behavior.</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004004</METRIC_ID>
    <DESCRIPTION_TYPE_ID>2</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>This check detects anytime the memory for a stack variable declared in a function is accessed after that function returns. Attempting to access stack memory after a function return can result in a crash or other unpredictable behavior.</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004004</METRIC_ID>
    <DESCRIPTION_TYPE_ID>3</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Avoid return Pointer, because memory exists and is destroyed automatically at the end of the function body</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004004</METRIC_ID>
    <DESCRIPTION_TYPE_ID>5</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Avoid return Pointer, because memory exists and is destroyed automatically at the end of the function body</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004004</METRIC_ID>
    <DESCRIPTION_TYPE_ID>6</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Avoid return Pointer, because memory exists and is destroyed automatically at the end of the function body fixed.</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004004</METRIC_ID>
    <DESCRIPTION_TYPE_ID>7</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Avoid return Pointer, because memory exists and is destroyed automatically at the end of the function body</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004004</METRIC_ID>
    <DESCRIPTION_TYPE_ID>8</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Number of pointers and it's memory allocation</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004004</METRIC_ID>
    <DESCRIPTION_TYPE_ID>9</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Avoid return Pointer, because memory exists and is destroyed automatically at the end of the function body</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004006</METRIC_ID>
    <DESCRIPTION_TYPE_ID>0</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Once memory is applied with malloc, it should be immediately checked whether the pointer value is NULL</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004006</METRIC_ID>
    <DESCRIPTION_TYPE_ID>1</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Unfortunately, many programmers are careless about checking of pointers, and sometimes they deliberately do not check whether to memory was allocated or not. 
	    It  does not guarantee that there will be enough of physical memory, when we begin to use the allocated memory buffer. 
	    Therefore, if there are still no guarantees, it is not necessary to perform a check.
	    
		
	    </METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004006</METRIC_ID>
    <DESCRIPTION_TYPE_ID>2</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>If the malloc function is unable to allocate the memory buffer, it returns NULL. 
	    Any normal program should check the pointers which the malloc function returns and properly handle the situation when the memory allocation failed.
	    </METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004006</METRIC_ID>
    <DESCRIPTION_TYPE_ID>3</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Once memory is applied with malloc, it should be immediately checked whether the pointer value is NULL
	    
			    &lt;a href="https://cwe.mitre.org/data/definitions/690.html"&gt;CWE-690: Unchecked Return Value to NULL Pointer Dereference&lt;/a&gt;
	    
	    	    &lt;a href="https://cwe.mitre.org/data/definitions/252.html"&gt;CWE-252: Unchecked Return Value&lt;/a&gt;
	    
	    		&lt;a href="https://cwe.mitre.org/data/definitions/476.html"&gt;CWE-476: NULL Pointer Dereference&lt;/a&gt;
	    </METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004006</METRIC_ID>
    <DESCRIPTION_TYPE_ID>5</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Once memory is applied with malloc, it should be immediately checked whether the pointer value is NULL
			    &lt;a href="https://cwe.mitre.org/data/definitions/690.html"&gt;CWE-690: Unchecked Return Value to NULL Pointer Dereference&lt;/a&gt;
	    
	    	    &lt;a href="https://cwe.mitre.org/data/definitions/252.html"&gt;CWE-252: Unchecked Return Value&lt;/a&gt;
	    
	    		&lt;a href="https://cwe.mitre.org/data/definitions/476.html"&gt;CWE-476: NULL Pointer Dereference&lt;/a&gt;
	    </METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004006</METRIC_ID>
    <DESCRIPTION_TYPE_ID>6</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>
	    Once memory is applied with malloc, it should be immediately checked whether the pointer value is NULL fixed.
	    	 int *piBuffer = NULL; 
	    	 
	    	 //creating integer of size n. 
	    	 piBuffer = (int*) malloc(20); 
	    	 
	    	 //make sure pcBuffer is valid or not with NULL, before using every where &amp; each time 
	    	 if ( piBuffer == NULL ) { 
	    	 	// piBuffer is NULL, be alert. 
	    	 } else {
				// piBuffer can be used for any business logic here. 
	    	 } 
		</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004006</METRIC_ID>
    <DESCRIPTION_TYPE_ID>7</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Once memory is applied with malloc, it should be immediately checked whether the pointer value is NULL</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004006</METRIC_ID>
    <DESCRIPTION_TYPE_ID>8</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Number of pointers and it's memory allocation</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004006</METRIC_ID>
    <DESCRIPTION_TYPE_ID>9</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Once memory is applied with malloc, it should be immediately checked whether the pointer value is NULL</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004008</METRIC_ID>
    <DESCRIPTION_TYPE_ID>0</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Set the pointer to NULL immediately after freeing memory with free to prevent 'Wild Pointers'</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004008</METRIC_ID>
    <DESCRIPTION_TYPE_ID>1</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Set the pointer to NULL immediately after freeing memory with free to prevent 'Wild Pointers'</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004008</METRIC_ID>
    <DESCRIPTION_TYPE_ID>2</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>
	    In this cases, pointers has not been initialized to anything (not even NULL) is known as wild pointer. 
	    The pointer may be initialized to a non-NULL garbage value that may not be a valid address.
	    
		</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004008</METRIC_ID>
    <DESCRIPTION_TYPE_ID>3</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Wild pointers needs to be freed with free() and then immediately set it to NULL</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004008</METRIC_ID>
    <DESCRIPTION_TYPE_ID>5</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>

			int *ptrFlag; 
			
			int *ptrFlag = (int *)malloc(sizeof(int));
			// Any statements;
	
			free (ptrFlag);
			
			ptrFlag = NULL; 
     	    
		</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004008</METRIC_ID>
    <DESCRIPTION_TYPE_ID>6</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>
	    Set the pointer to NULL immediately after freeing memory with free to prevent 'Wild Pointers' fixed.
	          int *ptrFlag; // This is Wild pointer
	          int count = 10;
	          for (int i=0; i&lt;=count; i++)
	          	// process count
	    </METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004008</METRIC_ID>
    <DESCRIPTION_TYPE_ID>7</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Wild pointer is assigned with proper memory and and released by setting pointer to NULL immediately after freeing memory with free()</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004008</METRIC_ID>
    <DESCRIPTION_TYPE_ID>8</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Number of pointers and it's memory allocation</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
  <DSS_METRIC_DESCRIPTIONS>
    <METRIC_ID>2004008</METRIC_ID>
    <DESCRIPTION_TYPE_ID>9</DESCRIPTION_TYPE_ID>
    <LANGUAGE>ENGLISH</LANGUAGE>
    <METRIC_DESCRIPTION>Set the pointer to NULL immediately after freeing memory with free to prevent 'Wild Pointers'</METRIC_DESCRIPTION>
  </DSS_METRIC_DESCRIPTIONS>
</DATA>